/*
目的：选择排序，要求用函数来做数组元素交换

输入输出格式说明：
1，每一行末尾可见字符后面没有不可见字符；
2，每一行的末尾都有一个换行符，但是最后一行没有换行符；
3，如果只有一行，则末尾没有换行符；
4，所有标点符号均为西文标点符号。

题目描述：
写一程序，实现下面的选择排序。输入一个正整数n（1<=n<=10），以及n个整数，
程序利用选择排序对这n个整数进行排序，并输出排序后的n个整数。

选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，
再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
以此类推，直到所有元素均排序完毕。
选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，
则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到
其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有
的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

输入样例：
10
5 1 2 6 4 9 8 7 3 10

输出样例：
1 2 3 4 5 6 7 8 9 10
*/

#include<stdio.h>
void swap(int *, int *);
void selection_sort(int [], int);
int main()
{
    int arr[10];
    int i, n;

    scanf("%d", &n);
    for (i = 0; i < 10; i++)
    {
        scanf("%d", &arr[i]);
    }

    selection_sort(arr, n);
    printf("%d", arr[0]);
    for (i = 1; i < n; i++)
    {
        printf(" %d", arr[i]);
    }

    return 0;
}
void selection_sort(int arr[], int len)
{
    int i,j;

	for (i = 0 ; i < len - 1 ; i++)
    {
		int min = i;
		for (j = i + 1; j < len; j++)       //走訪未排序的元素
			if (arr[j] < arr[min])          //找到目前最小值
				min = j;                    //紀錄最小值
	   	swap(&arr[min], &arr[i]);           //做交換
	}
}
void swap(int *a, int *b)                   //交換兩個變數
{
    int temp = *a;
    *a = *b;
    *b = temp;
}